//Tesselation evaluation shader template

{% include  "00_Generic_Common_VersionTag.glsl" %}
{% include  "01_Generic_Common_precisionTag.glsl" %}

//layout(triangles, equal_spacing, cw) in;
layout(triangles, equal_spacing, ccw) in;


//---- shader interface ----------------------
//input from vertex/tessEval shader
in InterfaceData
{
  {% include  "09_Generic_InterfaceData.glsl" %}
} input[];
//output to fragment shader
out InterfaceData
{
  {% include  "09_Generic_InterfaceData.glsl" %}
} output;
//--------------------------------------------


uniform sampler2D displacementMap;
uniform sampler2D normalMap;

uniform float displacementIntensity = 1.0f;


{% if not layeredRendering %}
    //we have to calculate final gl_Position value in this stage as there is no geometry shader to do it^^
    uniform mat4 viewMatrix;
    uniform mat4 projectionMatrix;
    uniform mat4 viewProjectionMatrix;
{% endif %}
{% if SHADOW_FEATURE_EXPERIMENTAL_SHADOWCOORD_CALC_IN_FRAGMENT_SHADER and LIGHT_SOURCES_SHADOW_FEATURE_ONE_SPOT_LIGHT %}
          uniform mat4 shadowMapLookupMatrix;  //bias*perspLight*viewLight * (camView)‚Åª1  for light calcs in view space
{% endif %}


//in vec3 tcPosition[];
//out vec3 tePosition;
//out vec3 tePatchDistance;
//uniform mat4 Projection;
//uniform mat4 Modelview;

void main()
{    
  //------------ following barycentric weighted output of vertex shader-computed variables ---------
  
  #define BARYCENTRIC_WEIGHTED(var) ( gl_TessCoord.x * input[0].var + gl_TessCoord.y * input[1].var + gl_TessCoord.z * input[2].var )
  
  output.position =   BARYCENTRIC_WEIGHTED(position);
  output.normal   =   BARYCENTRIC_WEIGHTED(normal);
  {% if SHADING_FEATURE_NORMAL_MAPPING %}
    output.tangent =  BARYCENTRIC_WEIGHTED(tangent);
  {% endif %}
  output.texCoords =  BARYCENTRIC_WEIGHTED(texCoords);
  
  //grab four linearly interpolated depth values to get a smooth offset:
  //TODO uncomment displacement code when tesselation is stable
  //output.position +=  output.normal * displacementIntensity * textureGather(displacementMap, output.texCoords.xy, 0 );
  output.position -=  output.normal * displacementIntensity * (textureGather(normalMap, output.texCoords.xy, 3 ) - 0.5 );
  
  {% if not layeredRendering %} 
    //if layered rendering, the world space position will be transformed in geometry shader;
    //if not, the viewspace position is transformed here:
    gl_Position = projectionMatrix * output.position;
    
   {% if SHADOW_FEATURE_EXPERIMENTAL_SHADOWCOORD_CALC_IN_FRAGMENT_SHADER and LIGHT_SOURCES_SHADOW_FEATURE_ONE_SPOT_LIGHT %}
      output.shadowCoord = shadowMapLookupMatrix * output.position;
    {% endif %}
  {% endif %}

  {% if RENDERING_TECHNIQUE_PRIMITIVE_ID_RASTERIZATION or instancedRendering %}
    output.genericIndices = input[0].genericIndices;
  {% endif %}
  
  //do NOT pass the depthButNotSpotLight-optimization variables as they are just redundancy on this stage where
  //the full 3D-pos vector has already been written to; (hard optimization is not the primary goal atm);   
    
}
