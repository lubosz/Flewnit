//Tesselation evaluation shader template

{% include  "00_Generic_Common_VersionTag.glsl" %}
{% include  "01_Generic_Common_precisionTag.glsl" %}

//layout(triangles, equal_spacing, cw) in;
layout(triangles, equal_spacing, ccw) in;


//---- shader interface ----------------------
//input from vertex/tessEval shader
in InterfaceData
{
  {% include  "09_Generic_InterfaceData.glsl" %}
} input[];

patch in int dispMapHigherResLod;
patch in float lodLevelInterpolationFactor;

//output to fragment shader
out InterfaceData
{
  {% include  "09_Generic_InterfaceData.glsl" %}
} output;
//--------------------------------------------


uniform sampler2D displacementMap;
uniform sampler2D normalMap;

uniform float displacementIntensity = 1.0f;


{% if not layeredRendering %}
    //we have to calculate final gl_Position value in this stage as there is no geometry shader to do it^^
    uniform mat4 viewMatrix;
    uniform mat4 projectionMatrix;
    uniform mat4 viewProjectionMatrix;
{% endif %}
{% if SHADOW_FEATURE_EXPERIMENTAL_SHADOWCOORD_CALC_IN_FRAGMENT_SHADER and LIGHT_SOURCES_SHADOW_FEATURE_ONE_SPOT_LIGHT %}
          uniform mat4 shadowMapLookupMatrix;  //bias*perspLight*viewLight * (camView)‚Åª1  for light calcs in view space
{% endif %}


//in vec3 tcPosition[];
//out vec3 tePosition;
//out vec3 tePatchDistance;
//uniform mat4 Projection;
//uniform mat4 Modelview;

void main()
{    
  //------------ following barycentric weighted output of vertex shader-computed variables ---------
  
  #define BARYCENTRIC_WEIGHTED(var) ( gl_TessCoord.x * input[0].var + gl_TessCoord.y * input[1].var + gl_TessCoord.z * input[2].var )
  
  output.position =   BARYCENTRIC_WEIGHTED(position);
  output.normal   =   BARYCENTRIC_WEIGHTED(normal);
  {% if SHADING_FEATURE_NORMAL_MAPPING %}
    output.tangent =  BARYCENTRIC_WEIGHTED(tangent);
  {% endif %}
  output.texCoords =  BARYCENTRIC_WEIGHTED(texCoords);
  
  //grab four linearly interpolated depth values to get a smooth offset:
  //TODO uncomment displacement code when tesselation is stable
  //output.position +=  output.normal * displacementIntensity * textureGather(displacementMap, output.texCoords.xy, 0 );
  
  //vec4 displacementVec = (textureGather(normalMap, output.texCoords.xy, 3 ) - 0.5 );
  //float displacementVal = displacementVec.x + displacementVec.y + displacementVec.z + displacementVec.w;
  //displacementVal /= 4.0;
  float displacementVal = texelFetch(
          normalMap, 
          ivec2(
            output.texCoords.x * textureSize(normalMap,0).x,  
            output.texCoords.y * textureSize(normalMap,0).y
          ),
          0
        ).w 
        - 0.5;
  
  output.position -=  output.normal * displacementIntensity * displacementVal;// / clamp( 0.005* length(output.position.xyz), 1.0, 100.0 );
 
 /*
  float log2TexSize =  log2( textureSize(normalMap,0).x ) ;
  float lod =    log2TexSize / clamp( log2( gl_TessLevelInner[0] ),1.0,log2TexSize)  -1.0 ;
  lod =  clamp(lod,0.0,log2TexSize)  ;
  
  int intLodLower = int( floor(lod) );
  int intLodHigher = int( ceil(lod) );
  float lodFraction =  fract(lod); 
  
  float displacementLowerLod =         
    texelFetch(
          normalMap, 
          ivec2(
            output.texCoords.x * textureSize(normalMap,0).x,  
            output.texCoords.y * textureSize(normalMap,0).y
          ) / (intLodLower+1),
          intLodLower
        ).w 
        - 0.5 ;
    float displacementHigherLod =         
      texelFetch(
          normalMap, 
          ivec2(
            output.texCoords.x * textureSize(normalMap,0).x,  
            output.texCoords.y * textureSize(normalMap,0).y
          ) / (intLodHigher+1),
          intLodHigher
        ).w 
        - 0.5 ;
        
   float finalDisplacement = (1.0-lodFraction)* displacementLowerLod + lodFraction * displacementHigherLod;
                  
  output.position -=  output.normal * displacementIntensity * finalDisplacement;
  */


  {% if not layeredRendering %} 
    //if layered rendering, the world space position will be transformed in geometry shader;
    //if not, the viewspace position is transformed here:
    gl_Position = projectionMatrix * output.position;
    
   {% if SHADOW_FEATURE_EXPERIMENTAL_SHADOWCOORD_CALC_IN_FRAGMENT_SHADER and LIGHT_SOURCES_SHADOW_FEATURE_ONE_SPOT_LIGHT %}
      output.shadowCoord = shadowMapLookupMatrix * output.position;
    {% endif %}
  {% endif %}

  {% if RENDERING_TECHNIQUE_PRIMITIVE_ID_RASTERIZATION or instancedRendering %}
    output.genericIndices = input[0].genericIndices;
  {% endif %}
  
  //do NOT pass the depthButNotSpotLight-optimization variables as they are just redundancy on this stage where
  //the full 3D-pos vector has already been written to; (hard optimization is not the primary goal atm);   
    
}
