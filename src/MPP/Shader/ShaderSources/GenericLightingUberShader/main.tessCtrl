//Tesselation control shader template

{% include  "00_Generic_Common_VersionTag.glsl" %}
{% include  "01_Generic_Common_precisionTag.glsl" %}

layout(vertices = 3) out;

//own flickering (i.e. BAD) LOD criteria:
uniform vec2 viewPortHalfExtends = vec2(320.0,240.0);
uniform float targetEdgeLenghtInPixels = 25.0;

//metro 2033 LOD criteria:
uniform float numScreenPixels = 640.0;
uniform float tessQualityFactor = 0.05;

//---- shader interface ----------------------
//input from vertex/tessEval shader
in InterfaceData
{
  {% include  "09_Generic_InterfaceData.glsl" %}
} input[];
//output to fragment shader
out InterfaceData
{
  {% include  "09_Generic_InterfaceData.glsl" %}
} output[];

patch out float nonAlignedTessLevel;
//--------------------------------------------


float ceilToNexPowerOf2Minus1(float originalTessLevel)
{
  return exp2( ceil( log2(originalTessLevel)) ) -1.0;
}


void main()
{
/*
  //own flickering try:
  
  vec4 edgeStartHomog  = gl_in[ (gl_InvocationID + 1) % 3 ].gl_Position;
  vec4 edgeEndHomog    = gl_in[ (gl_InvocationID + 2) % 3 ].gl_Position;
  
  edgeStartHomog /= edgeStartHomog.w;
  edgeEndHomog /= edgeEndHomog.w;
  
  float edgeLenghtPixel =  length( (edgeEndHomog.xy - edgeStartHomog.xy) * viewPortHalfExtends.xy );
  
  gl_TessLevelOuter[gl_InvocationID] = edgeLenghtPixel / targetEdgeLenghtInPixels;

  barrier();
    
  if (gl_InvocationID == 0) 
  {
    //gl_TessLevelInner[0] = (gl_TessLevelOuter[0]+gl_TessLevelOuter[1]+gl_TessLevelOuter[2]) / 3.0;
    gl_TessLevelInner[0] = max(max(gl_TessLevelOuter[0],gl_TessLevelOuter[1]),gl_TessLevelOuter[2]);
  }
*/

//---------------------------------------------------------------------------------------

{%if not layeredRendering %} 
  //metro 2033 LOD criteria: TESS_FACT = LEN * NP * Q / DIST
  
  vec3 edgeStartVS = input[ (gl_InvocationID + 1) % 3 ].position.xyz;
  vec3 edgeEndVS   = input[ (gl_InvocationID + 2) % 3 ].position.xyz;
  float edgeLengthVS = length( edgeEndVS - edgeStartVS  );
  float edgeDistVS = length( 0.5 * ( edgeEndVS + edgeStartVS) );
  
  //float alignedTessLevelOuter = floor (edgeLengthVS * numScreenPixels * tessQualityFactor / edgeDistVS  * 0.5) * 2.0;
  //gl_TessLevelOuter[gl_InvocationID] = alignedTessLevelOuter ;
   
  float originalTessLevel = edgeLengthVS * numScreenPixels * tessQualityFactor / edgeDistVS ;
  gl_TessLevelOuter[gl_InvocationID] = ceilToNexPowerOf2Minus1(originalTessLevel);
   
  //gl_TessLevelOuter[gl_InvocationID] = floor (edgeLengthVS * numScreenPixels * tessQualityFactor / edgeDistVS  * 0.5) * 2.0 +1.0;
   
  barrier();
    
  if (gl_InvocationID == 0) 
  {
    //gl_TessLevelInner[0] = (gl_TessLevelOuter[0]+gl_TessLevelOuter[1]+gl_TessLevelOuter[2]) / 3.0; // + 2.0;
    //float nonAlignedTessLevel = (gl_TessLevelOuter[0]+gl_TessLevelOuter[1]+gl_TessLevelOuter[2]) / 3.0;
    //gl_TessLevelInner[0] = floor (nonAlignedTessLevel  * 0.5) * 2.0;
    
    gl_TessLevelInner[0] = min(min(gl_TessLevelOuter[0],gl_TessLevelOuter[1]),gl_TessLevelOuter[2])+1.0;
  }
  //barrier();
  //gl_TessLevelOuter[gl_InvocationID] = floor (gl_TessLevelOuter[gl_InvocationID]   * 0.5) * 2.0;
  
{% else %}

  TODO have to hack view space stuff into gl_Positiion 
  
{% endif %} 

//---------------------------------------------------------------------------------------


/*
    if (gl_InvocationID == 0) 
    {
        gl_TessLevelInner[0] = 1;
        
        gl_TessLevelOuter[0] = 5;
        gl_TessLevelOuter[1] = 25;
        gl_TessLevelOuter[2] = 45;
    }
*/    


  //------------ following only unmodified pass-through of vertex shader-computed variables ---------
  output[gl_InvocationID].position = input[gl_InvocationID].position; //pos will always be needed by tessEval
  output[gl_InvocationID].normal = input[gl_InvocationID].normal; //normal, too, for displacement
  {% if SHADING_FEATURE_NORMAL_MAPPING %}
      output[gl_InvocationID].tangent = input[gl_InvocationID].tangent;
  {% endif %}
  output[gl_InvocationID].texCoords = input[gl_InvocationID].texCoords; //also always needed for displ map lookup

  {% if RENDERING_TECHNIQUE_PRIMITIVE_ID_RASTERIZATION or instancedRendering %}
    output[gl_InvocationID].genericIndices = input[gl_InvocationID].genericIndices;
  {% endif %}
  //do NOT pass shadow coord, as projected stuff it must be newly calculated from displaced world/view space vertices
  //do NOT pass the depthButNotSpotLight-optimization variables as they are just redundancy on this stage where we need the full 3D-pos vector;       
}
