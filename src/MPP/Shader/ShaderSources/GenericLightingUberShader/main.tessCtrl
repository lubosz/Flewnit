//Tesselation control shader template

{% include  "00_Generic_Common_VersionTag.glsl" %}
{% include  "01_Generic_Common_precisionTag.glsl" %}

layout(vertices = 3) out;

uniform vec2 viewPortSize = vec2(640.0,480.0);
uniform float targetEdgeLenghtInPixels = 25.0;


//---- shader interface ----------------------
//input from vertex/tessEval shader
in InterfaceData
{
  {% include  "09_Generic_InterfaceData.glsl" %}
} input[];
//output to fragment shader
out InterfaceData
{
  {% include  "09_Generic_InterfaceData.glsl" %}
} output[];
//--------------------------------------------



void main()
{
    if (gl_InvocationID == 0) 
    {
        gl_TessLevelInner[0] = 11;
        
        gl_TessLevelOuter[0] = 11;
        gl_TessLevelOuter[1] = 11;
        gl_TessLevelOuter[2] = 11;
    }


  //------------ following only unmodified pass-through of vertex shader-computed variables ---------
  output[gl_InvocationID].position = input[gl_InvocationID].position; //pos will always be needed by tessEval
  output[gl_InvocationID].normal = input[gl_InvocationID].normal; //normal, too, for displacement
  {% if SHADING_FEATURE_NORMAL_MAPPING %}
      output[gl_InvocationID].tangent = input[gl_InvocationID].tangent;
  {% endif %}
  output[gl_InvocationID].texCoords = input[gl_InvocationID].texCoords; //also always needed for displ map lookup

  {% if RENDERING_TECHNIQUE_PRIMITIVE_ID_RASTERIZATION or instancedRendering %}
    output[gl_InvocationID].genericIndices = input[gl_InvocationID].genericIndices;
  {% endif %}
  //do NOT pass shadow coord, as projected stuff it must be newly calculated from displaced world/view space vertices
  //do NOT pass the depthButNotSpotLight-optimization variables as they are just redundancy on this stage where we need the full 3D-pos vector;       
}
