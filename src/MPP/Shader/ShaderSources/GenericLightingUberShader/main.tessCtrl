//Tesselation control shader template

{% include  "00_Generic_Common_VersionTag.glsl" %}
{% include  "01_Generic_Common_precisionTag.glsl" %}

layout(vertices = 3) out;

uniform vec2 viewPortHalfExtends = vec2(320.0,240.0);
uniform float targetEdgeLenghtInPixels = 25.0;


//---- shader interface ----------------------
//input from vertex/tessEval shader
in InterfaceData
{
  {% include  "09_Generic_InterfaceData.glsl" %}
} input[];
//output to fragment shader
out InterfaceData
{
  {% include  "09_Generic_InterfaceData.glsl" %}
} output[];
//--------------------------------------------



void main()
{

  vec4 edgeStartHomog  = gl_in[ (gl_InvocationID + 1) % 3 ].gl_Position;
  vec4 edgeEndHomog    = gl_in[ (gl_InvocationID + 2) % 3 ].gl_Position;
  
  edgeStartHomog /= edgeStartHomog.w;
  edgeEndHomog /= edgeEndHomog.w;
  
  float edgeLenghtPixel =  length( (edgeEndHomog.xy - edgeStartHomog.xy) * viewPortHalfExtends.xy );
  
  gl_TessLevelOuter[gl_InvocationID] = edgeLenghtPixel / targetEdgeLenghtInPixels;

  barrier();
    
  if (gl_InvocationID == 0) 
  {
    gl_TessLevelInner[0] = (gl_TessLevelOuter[0]+gl_TessLevelOuter[1]+gl_TessLevelOuter[2]) / 3.0;
  }

/*
    if (gl_InvocationID == 0) 
    {
        gl_TessLevelInner[0] = 1;
        
        gl_TessLevelOuter[0] = 5;
        gl_TessLevelOuter[1] = 25;
        gl_TessLevelOuter[2] = 45;
    }
*/    


  //------------ following only unmodified pass-through of vertex shader-computed variables ---------
  output[gl_InvocationID].position = input[gl_InvocationID].position; //pos will always be needed by tessEval
  output[gl_InvocationID].normal = input[gl_InvocationID].normal; //normal, too, for displacement
  {% if SHADING_FEATURE_NORMAL_MAPPING %}
      output[gl_InvocationID].tangent = input[gl_InvocationID].tangent;
  {% endif %}
  output[gl_InvocationID].texCoords = input[gl_InvocationID].texCoords; //also always needed for displ map lookup

  {% if RENDERING_TECHNIQUE_PRIMITIVE_ID_RASTERIZATION or instancedRendering %}
    output[gl_InvocationID].genericIndices = input[gl_InvocationID].genericIndices;
  {% endif %}
  //do NOT pass shadow coord, as projected stuff it must be newly calculated from displaced world/view space vertices
  //do NOT pass the depthButNotSpotLight-optimization variables as they are just redundancy on this stage where we need the full 3D-pos vector;       
}
